
# Q&A

<details >
  <summary>目录</summary>

  &emsp;&emsp;[1. 自动翻译原理与流程](#1-自动翻译原理与流程)<br/>
  &emsp;&emsp;[2.  `变量插值` 与 `插值变量` 有何不同？](#2--变量插值-与-插值变量-有何不同)<br/>
  &emsp;&emsp;[3.  `变量插值` 为什么不支持对象属性解析？](#3--变量插值-为什么不支持对象属性解析)<br/>
  &emsp;&emsp;[4.  `插值变量` 类型**日期**和**时间**分开有必要吗？](#4--插值变量-类型日期和时间分开有必要吗)<br/>
  &emsp;&emsp;[5. 是否会支持富文本文案？](#5-是否会支持富文本文案)<br/>

</details>

## 1. 自动翻译原理与流程
**流程：**
1. 提取文案
2. 调用翻译平台 API
3. 生成语言包

在整个流程中， `提取文案` 是最关键的环节。采用 `文案即 key` 的方式，既直观又便于编写，也便于脚本自动识别和处理内容



以下为 `文案即 key` 的示例
```js
const text = t('hello world')
```
 `自动翻译` 生成语言包的效果
```json
// zh.json
{
  "hello world": "你好世界"
}

// jp.json
{
  "hello world": "こんにちは世界"
}
```
但仅采用 `文案即 key` 方式也存在一定局限性：



* 不适用于一词多译场景



可通过 `t.t` 的 `key` 属性实现 `自定义 key` 来优化 `不适用于一词多译场景` 



以下为 `自定义 key` 的示例
```js
const text = t.t('custom-key', 'hello world')
```
 `自动翻译` 生成语言包的效果
```json
// zh.json
{
  "custom-key": "你好世界"
}

// jp.json
{
  "custom-key": "こんにちは世界"
}
```


使用 `自定义 key` 生成的语言包，即使 `文案` 变化，已生成的语言包不受影响

**每次 `自动翻译` 生成语言包文案的顺序**
1.  `自定义 key` 已翻译的
2.  `自定义 key` 已翻译的，基于 `文案即 key` 生成
3.  `自定义 key` 新翻译的
4.  `文案即 key` 已翻译的
5.  `文案即 key` 新翻译的


## 2.  `变量插值` 与 `插值变量` 有何不同？

```js
t('i18n-pro 用户数达到了{n0}', 100000000) // 数字
t('售价为{c0}', 14999) // 货币
t(`今天的日期是{d0}`, new Date()) // 日期
t('当前时间：{t0}', new Date()) // 时间
t('我有{p0个苹果}，{p1个香蕉}和{p2个梨}', 5, 4, 3) // 复数 
```
**变量插值**：指 `t('hello {0}', 'world')` → `'hello world'` 这个功能的实现<br />**插值变量**：指插入到文案中的变量<br />例如上面示例代码中的 `100000000` 、 `14999` 和 `newDate()` 等
*  `插值变量` 插入位置
   * 类似于{0}、{1}、{2}等
*  `插值变量` 类型标记
   * 类似于{n0}、{c1}、{t2}、{d3}、{p4个苹果}等


## 3.  `变量插值` 为什么不支持对象属性解析？
示例代码
```js
// 对象属性解析
t('我叫{name}，今年{age}岁，来自{base}，是一名{job}', {
  name: '王尼玛',
  age: 22,
  base: '火星',
  job: '码农',
})

// 当前库的下标解析
t('我叫{0}，今年{1}岁，来自{2}，是一名{3}',
  '王尼玛',
  '22',
  '火星',
  '码农',
)
```
主要原因是文案中包含属性名，不利于通过第三方平台翻译，上面的示例从中文翻译到英文还OK，如果是英文翻译到中文或其他语言， `插值变量` 中的属性名也会被翻译，这就是问题所在

对象属性解析的示例
```js
// 文案为中文
const zh = '我叫{name}，今年{age}岁，来自{base}，是一名{job}'

// 通过百度翻译成英文，看似OK的
const zhToEn = `My name is {name}. I'm {age} years old. I'm from {base}. I'm a {job} `

// 再通过百度翻译将上面的英文翻译成中文，可以发现{job}的翻译就出问题了，而且不同的翻译平台，可能出现在的问题也不一样
const enToZh = '我的名字是｛name｝。我{age}岁。我来自{base}。我是{工作}'
```
再来看看下标解析的示例
```js
// 文案为中文
const zh = '我叫{0}，今年{1}岁，来自{2}，是一名{3}'

// 通过百度翻译成英文
const zhToEn = `My name is {0}. I'm {1} years old. I'm from {2}. I'm a {3}`

// 通过百度翻译将上面的英文翻译成中文，不会出现上面参数匹配不上的问题
const enToZh = '我的名字是｛0｝。我是｛1｝岁。我来自｛2｝。我是｛3｝'
```
虽然通过机器翻译本来就不能做到100%的准确率，但是这种方式可以尽量避免不必要的错误
## 4.  `插值变量` 类型**日期**和**时间**分开有必要吗？
个人感觉其实是没有必要的，只是设计上已经实现了，大家可以酌情灵活选择使用，当然不排除有的业务场景这样分开处理会更方便
## 5. 是否会支持富文本文案？
不支持富文本文案。自动翻译要求 `文案` 为纯文本，富文本与现有实现逻辑冲突<br /><br />**如需富文本效果，可通过 `变量插值` 实现**<br />例如这里的文案是 `hello world` ，页面上需要将 `world` 显示为红色粗体的样式<br />**方案一**
```js
t('hello {0}world{1}', '<b style="color:red;">', '</b>')

// t 函数执行后返回结果：hello <b style="color:red;">world</b>
```
**方案二**<br />
```js
t('Hello {0}', `<b style="color:red;">${t('world')}</b>`)

// t 函数执行后返回结果：hello <b style="color:red;">world</b>
```
可根据实际需求选择上述方案